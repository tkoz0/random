#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

#define LOMASK ((1UL<<56) - 1)

// stores lower 56 bits in lo and all higher bits in hi
typedef struct { uint64_t lo, hi; } NUM_T;

// numbers modulo 2^56
const uint64_t LO56[100] =
{
    49358056305482605, 62425860880523552, 63772143341169379,  5166998042748712,
    29821718707829609, 20514003362636514, 64896906471655448, 22902651073069237,
    49224737451604962,  1917627132984362,  6493686898469897, 30922184852112194,
    24071877967672407, 24288392363185782, 33397274433060773, 53023917779645922,
    25073482848622778, 69817744874289715, 55675456406883311, 59156488290620291,
     5285160016495132, 51651901491393944, 22960988507619815, 40972546372029527,
    17965381759424197, 54213112757876599, 66068400374174904, 16360976595228759,
    26520778277835927, 47880599643440896, 67740979648112056, 63058947993958429,
     3726643157549935, 15329421996091841, 68773773195038935, 60358037769640221,
    42440069690795812, 47194775040684140, 19104978875374635, 22159385361889886,
    36129587719482213, 69935303097663913, 67545426558072654, 55342901203423077,
    70413993542951126, 69910034158737286, 16707188167211631, 34744506915827921,
    64894453884358934, 43042793022024562, 22005692386223609, 52330424331761609,
    59347792799756898, 23654470722684896, 25195781274779063, 25456740139036121,
    71035581140425360, 60379833778583625, 68080453684234314, 49162071705672554,
     3806894565807195, 48420672448428454, 66213484835739757,  8727298341213686,
    43092766639609653, 29652935694510701, 18682681418252321, 69053122337323514,
     3767680857723869, 58691318624504080, 67184216518956965, 22536229352291094,
    36604991797260202,  9960536158714744, 29131962835509140,  5379173141228738,
    24453348301033465, 22083635715660207, 12969900057217344, 21172701946395238,
    55690945888494680, 19535481335645134, 47393630925468328,    97713248543598,
    49190569682484748, 41304590684336101, 46636109977582543, 10107728529689151,
     4555046496451307,  9357201257642003, 62502494464776802, 51464474066204435,
    65203842746800286,  5700515264069434, 14658101158450901, 32435606915611763,
    52165686552319036, 60143067507677011, 23113349891010490,  2662952289529550
};

// numbers divided by 2^56 (integer part)
const uint64_t HIBITS[100] =
{
     79378523109,  76160548462,  66166052244,  25756124452,  59532606963,
    110566166802,  35707093915,  17966005654,  66119521459,  20460628217,
     35785954251,  71631547710,  31122780727, 103725217506,  86206814927,
     68593967082,  76553546275,  81251154687,  73742278560,  93504256479,
     59568858380,  62012391275,  36618232499,  17471056042,  62204126950,
    121428635511,  15495930343,  53834898672, 127847165237,  46507564241,
    122899403470,  60130504559,  33705699098,  93515221495, 122046167230,
     41490342353,  84896734475,  38328430511,  95537671482, 120345805798,
    130883593369,  66453074496,  50303611938, 129921348183, 137297333448,
     82068046661, 115378422768,  31445195593,  48255625730,  87726348581,
     24930608894,  88349501766, 118592060416,  46661163630, 117468172222,
     40146463436,  59628606741, 119831431128, 116784835179,  31465847350,
     65085601458,  61461485733,  99174768213,  31555644397,  92788731161,
     43874880070,  26612204464,  48800290715, 104772921682,  33277223689,
     64890374432,  39309045482, 121506176966, 136469486069,  73533835318,
    136800472050,  20417364248,  49202855322,  93472002595,  29721582891,
    117707888676, 138239659112, 137962391461,  86627614713,  60296816314,
    105038791036,  38533364830,  85685614124,  74767749374,  73797819985,
     91761910785,  18248299922,  33956555168, 135817660989,  40616383017,
     52616609326,  39298116360,  45537009627, 138149833169,  47383474138
};

// expect pointer to 16 bytes of raw subset data
// TODO speedup with cache
NUM_T subset_sum(const void *subset)
{
    NUM_T result = { 0, 0 };
    uint64_t lower = *((uint64_t*)subset); // lower 64 bits as lower endian
    uint32_t hi1 = ((uint32_t*)subset)[2];
    uint32_t hi2 = ((uint32_t*)subset)[3];
    uint64_t higher = (hi1 & 0x1FF) | ((hi1 >> 23) << 9)
                    | ((hi2 & 0x1FF) << 18) | ((hi2 >> 23) << 27);
    uint32_t num_i = 0, i = 64;
    while (i--) // first 64 numbers
    {
        result.lo += (lower & 1) * LO56[num_i];
        result.hi += (lower & 1) * HIBITS[num_i];
        lower >>= 1;
        ++num_i;
    }
    i = 36;
    while (i--) // last 36 numbers
    {
        result.lo += (higher & 1) * LO56[num_i];
        result.hi += (higher & 1) * HIBITS[num_i];
        higher >>= 1;
        ++num_i;
    }
    result.hi += result.lo >> 56;
    result.lo &= LOMASK;
    return result;
}

// each pointer should point to 16 bytes of subset data
int subset_compare(const void *a, const void *b)
{
    NUM_T a_sum = subset_sum(a);
    NUM_T b_sum = subset_sum(b);
    if (a_sum.hi > b_sum.hi) return 1;
    if (a_sum.hi < b_sum.hi) return -1;
    if (a_sum.lo > b_sum.lo) return 1;
    if (a_sum.lo < b_sum.lo) return -1;
    return 0;
}

// TODO write sorted data buffer to a new file
int main(int argc, char **argv)
{
    assert(argc >= 2);
    int fd = open(argv[1],O_RDONLY);
    uint64_t fdsize = lseek(fd,0,SEEK_END);
    assert(fdsize != -1);
    lseek(fd,0,SEEK_SET);
    assert((fdsize & 15) == 0); // needs to be multiple of 16 bytes
    printf("reading file...\n");
    void *data = malloc(fdsize);
    if (read(fd,data,fdsize) != fdsize)
    {
        printf("ERROR did not read expected file size\n");
        return 1;
    }
    printf("sorting data...\n");
    qsort(data,fdsize>>4,16,subset_compare);
    printf("looking for duplicates...\n");
    uint32_t *ptr = data;
    uint64_t count = fdsize>>4, i;
    NUM_T prev_sum = subset_sum(ptr), cur_sum;
    for (i = 1; i < count; ++i)
    {
        ptr += 4; // advance 16 bytes
        cur_sum = subset_sum(ptr);
        if (prev_sum.lo == cur_sum.lo && prev_sum.hi == cur_sum.hi)
            printf("pair: subsets %lu and %lu\n",i-1,i);
        prev_sum = cur_sum;
    }
    printf("DONE\n");
    return 0;
}
